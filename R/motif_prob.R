#' Calculate the probability of motif occurrence in each sequence
#' @description This function calculates the probability of motif occurrence in each sequence and counts the number of non-overlapping motif occurrences.
#' The probability of motif occurrence is calculated using a Markov chain and becomes increasingly computationally exhaustive given the length and number of motifs.
#' Therefore, the function is parallelized to speed up computation and at least 16 cores with 128 GB of RAM is recommended when running the function for all 7-mers.
#'
#' @param motifs a vector of motifs (e.g., c("ACGTAGT", "GTACAAG")) or an integer specifying the k-mers to be used (e.g., 7 for all 7-mers). A motif is specified as a regular expression on the alphabet {A,C,G,T}.
#' @param seqs a dataframe with the columns: 'gid', 'sequence', and 'nchar' (generated by build_seq_list()).
#' @param seqlist a list of sequences (generated by build_seq_list()).
#' @param paths boolean specifying whether the input data is provided as file paths or as R objects.
#' @param binom_approx boolean specifying whether to use a binomial approximation to calculate motif probabilities or the default n-step TPM assuming an underlying Markov chain. The binomial method assumes equal nucleotide frequencies
#' as well as a random and independent distribution of nucleotides in the sequence of interest. The approach is most appropriate when considering a large set of longer k-mers (> 7-mers). If binom_approx = T, 'motifs' has to be specified as a k-mer (e.g., motifs = 8 for all 8-mers).
#' @param cores number of cores to use for parallelization. Consider increasing number of cores for long k-mers (default is the number of cores available).
#' @param out_path path to output directory (default is NULL, where the output is returned rather than saved).
#' @param include_counts the default is TRUE and ensures that the matrix with motif counts is also returned. This parameter should ONLY be FALSE when running a light-weight approx. approach on a smaller computer.
#'
#' @return two matrices, motif_probs and motif_counts, containing sequence-specific motif probabilities and motif counts, respectively.
#' @export
#'
#' @examples
#' \dontrun{
#' motif_prob_count_lst <- motif_prob(motifs = c("ACGTAGT", "GTACAAG"),
#' seqs = "./seqs.rds", seqlist = "./seqlist.rds",
#' binom_approx = F, cores = 4)
#'
#' motif_prob(motifs = 7, seqs = seqs, seqlist = seqlist, paths = F,
#' binom_approx = T, out_path = "./")
#' }
#'
#'
#'
motif_prob <- function(motifs, seqs, seqlist, paths = T, binom_approx = F, cores = parallel::detectCores(),
                       out_path = NULL, include_counts = T) {

  # load data if file paths are provided
  if(paths) {
    seqs <- readRDS(seqs)
    seqlist <- readRDS(seqlist)
  }
  # check if integer is specified to obtain all k-mers
  if (is.integer(motifs)){
    motifs <- Regmex::all.mers(motifs)
  }

  ## Extract non-overlapping motif counts for each sequence ##
  if (include_counts) { # consider adding grep for binom_approx == T (Faster approach to getting count data)
    motif_counts <- do.call(cbind, parallel::mclapply(motifs, function(x) Regmex::n.obs.mot(x, seqlist, overlap =F), mc.cores = cores))
    colnames(motif_counts) <- motifs
    rownames(motif_counts) <- seqs$gid # match sequence and expression names/gene IDs
  }

  ## Calculate motif probabilities for each sequence ##
  if (binom_approx == F) {
    # generate state-space matrix (used to construct Markov chain; consisting of initial state and transition probabilities)
    pat.con <- utils::getFromNamespace("pat.con", "Regmex")
    patterns <- parallel::mclapply(motifs, function(x) pat.con(x, overlap = F), mc.cores = cores)
    names(patterns) <- motifs

    # compute probability of motif occurrence in each sequence
    motif_probs <- do.call(cbind, parallel::mclapply(patterns, function(x) unlist(lapply(seqlist, function(y) bayesReact::pd_mrs2(x,y))), mc.cores = cores))
    colnames(motif_probs) <- motifs
    rownames(motif_probs) <- seqs$gid # match sequence and expression names/gene IDs

    # check for NAs
    if(NA %in% motif_probs) stop("NA introduced when calculating motif probabilities. Try checking input data for errors.", call. = F)

  } else { # Binomial approximation (consider MMN implementation, which works for all REs)

    # check that the method is only used for k-mers
    if(!is.numeric(motifs)) stop("'motifs' should be an integer specifying k-mers to by used. Alternatively, consider using binom_approx = F.", call. = F)

    # calculate probability of at least one motif occurrence in each sequence
    binom_prob <- function(motif, seq_freq, seq_len){
      mot_len <- nchar(motif)
      motif <- unlist(strsplit(motif, ""))
      trials <- seq_len - mot_len + 1 # number of trials is the number of positions where a motif can potentially occur in the sequence
      mot_occ_prob <- unlist(lapply(motif, function(x) seq_freq[x])) # probability of each nucleotide in the motif is its frequency in the sequence
      mot_occ_prob <- prod(mot_occ_prob) # probability of motif occurrence (success at each trial) is the product of the probabilities of each nucleotide in the motif

      # probability of no motif occurrence in the sequence is the probability of failure at each trial
      no_motif_prob <- (1 - mot_occ_prob)^trials
      # probability of at least one motif occurrence in the sequence thus becomes '1 - probability of no motif occurrence'
      return(1 - no_motif_prob)
    }

    # calculate motif probabilities for each motif in each sequence
    motif_probs <- do.call(rbind, parallel::mclapply(motifs, function(x) unlist(lapply(seqlist, function(y) binom_prob(x, y[2]$freq.mono, y[5]$length))), mc.cores = cores))
    rownames(motif_probs) <- motifs
    colnames(motif_probs) <- seqs$gid # match sequence and expression names/gene IDs
    motif_probs <- t(motif_probs) # transpose to match the output format from the non-approximate approach
  }

  ## Save or return motif probabilities ##
  if (include_counts == F){
    if (is.character(out_path)) {
      saveRDS(motif_probs, file = paste0(out_path, "seqXmot_probs.rds"))
      return(list(motif_probs_path = paste0(out_path, "seqXmot_probs.rds"))) # used by process_raw_input()
    } else {
      return(motif_probs)
    }
  }

  if (is.character(out_path)) {
    saveRDS(motif_counts, file = paste0(out_path, "seqXmot_counts.rds"))
    saveRDS(motif_probs, file = paste0(out_path, "seqXmot_probs.rds"))
    return(list(motif_probs_path = paste0(out_path, "seqXmot_probs.rds"), motif_counts_path = paste0(out_path, "seqXmot_counts.rds"))) # used by process_raw_input()
  } else {
    return(list(motif_probs = motif_probs, motif_counts = motif_counts))
  }
}
